Объект – это конкретный экземпляр [[класса]]. Объекты создаются с использованием оператора `new` и инициализируются с помощью конструктора класса. Вот пример создания объекта типа `Person`:

![[Pasted image 20240716152826.png]]

### [[Объект обладает интерфейсом]]
![[Pasted image 20240716152119.png]]

### Объект предоставляет услуги

В хорошо спланированном объектно-ориентированном проекте каждый объект хорошо справляется с одной конкретной задачей, не пытаясь при этом сделать больше нужного

### [[Скрытая реализация]]
Принцип [[инкапсуляции]] является одним из основных принципов объектно-ориентированного программирования. Он позволяет скрыть внутреннюю реализацию объекта и предоставить доступ к его состоянию и поведению только через определенные методы.
### Повторное использование реализации
**Повторное использование кода** — одно из важнейших преимуществ языков объектно-ориентированного программирования. В Java можно использовать уже существующие классы, которые кто-то уже создал и проверил на работоспособность.

Существует два пути реализации этой идеи:

1. **[[Композиция (composition)]]** — объекты уже имеющихся классов просто создаются внутри нового класса. Программист использует функциональность уже готового кода.
							
	![[Pasted image 20240731142245.png]]
    
2. **Наследование (inheritance)** — новый класс создается как специализация уже существующего класса. Взяв существующий класс за основу, можно добавить к нему свой код без изменения существующего класса.

### [[Взаимозаменяемые объекты и полиморфизм]]
Полиморфизм — это один из основных принципов объектно-ориентированного программирования (ООП), который позволяет объектам разных типов быть обработанными единообразно. В Java полиморфизм позволяет методам выполнять разные действия в зависимости от объекта, который вызывает метод. Это делает код более гибким и расширяемым. Полиморфизм можно рассматривать как способность одного интерфейса быть реализованным несколькими способами. Например, метод `draw()` может быть реализован по-разному для объектов классов `Circle`, `Square` и `Triangle`, но вызывать его можно через один и тот же интерфейс `Shape`.
## Типы полиморфизма в Java

### Компиляторный полиморфизм (статический)

Компиляторный полиморфизм достигается через перегрузку методов и операторов. Это означает, что в одном классе могут быть несколько методов с одинаковым именем, но с разными параметрами. Компилятор решает, какой метод вызвать, основываясь на типе и количестве аргументов. Перегрузка методов позволяет создавать несколько версий одного и того же метода, которые могут принимать разные параметры и выполнять различные действия.

Пример перегрузки метода:

```java
class MathUtils {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

В этом примере метод `add` перегружен тремя способами: для двух целых чисел, для двух чисел с плавающей точкой и для трех целых чисел. Компилятор определяет, какой метод вызвать, основываясь на типе и количестве аргументов, переданных при вызове метода.

### Ранний полиморфизм (динамический)

Ранний полиморфизм достигается через переопределение методов. Это позволяет подклассам предоставлять конкретную реализацию методов, объявленных в суперклассе или интерфейсе. В этом случае метод, который будет вызван, определяется во время выполнения программы. Переопределение методов позволяет создавать более специализированные версии методов, которые могут выполнять конкретные действия, характерные для подклассов.

Пример переопределения метода:

```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Cat meows");
    }
}
```

В этом примере метод `sound` переопределен в классах `Dog` и `Cat`. Когда метод `sound` вызывается для объекта типа `Dog`, он выводит "Dog barks", а когда для объекта типа `Cat`, он выводит "Cat meows". Это демонстрирует, как динамический полиморфизм позволяет объектам разных типов выполнять различные действия при вызове одного и того же метода.

### [[Контейнеры]]
**Коллекции** или **контейнеры** — это классы позволяющие хранить и производить операции над множеством объектов.

Стандартный набор коллекций Java служит для избавления программиста от необходимости самостоятельно реализовывать эти типы данных и снабжает его дополнительными возможностями.

Интерфейсы в Collections Framework играют ключевую роль. Все классы коллекций реализуют различные интерфейсы, которые определяют поведение коллекции.

Интерфейс определяет «что делает коллекция», а конкретная реализация — «как коллекция делает то, что определяет интерфейс».

При разработке приложений рекомендуется там, где возможно, использовать интерфейсы. Такая организация позволяет легко заменять реализацию интерфейса, с целью повышения производительности, а также позволяет разработчику сконцентрироваться на задаче, а не на особенностях реализации.

Взаимодействие интерфейсов коллекций и карт:

![](https://studfile.net/html/2706/635/html_cLtZyS5cjt.Ab9a/img-BVzjSo.png)

Инструментальный набор:

|**Интерфейс**|**Классы**|
|---|---|
|Collection|-|
|Set|HashSet LinkedHashSet|
|SortedSet|TreeSet|
|Queue|PriorityQueue|
|Deque|ArrayDeque|
|List|ArrayList Vector<br><br>Stack LinkedList|
|Map|HashMap Hashtable<br><br>LinkedHashMap|
|SortedMap|TreeMap|
Интерфейс Collection содержит набор общих методов, которые используются в большинстве коллекций:

- **boolean** **add(Object** **obj****)** – добавляет в коллекцию новый элемент, если элементы коллекции упорядочены, то новый элемент добавляется в конец коллекции, в коллекцию Set элемент добавляется только, если такого нет в коллекции;
    
- **boolean** **contains****(Object obj)** – возвращает true, если объект obj содержится в коллекции и false, если нет;
    
- **boolean** **isEmpty****()** – проверяет, пуста ли коллекция;
    
- **boolean** **remove****(Object obj)** – удаляет из коллекции элемент obj, возвращает false, если такого элемента в коллекции не нашлось;
    
- **int** **size****()** – возвращает количество элементов коллекции.

### [[Параметризованные типы]]
**Дженерики (или обобщения)** - это параметризованные типы.

Параметризованные типы позволяют объявлять классы, интерфейсы и методы, где тип данных, которыми они оперируют, указан в виде параметра. Используя дженерики, можно создать единственный класс, например, который будет автоматически работать с разными типами данных.

Классы, интерфейсы или методы, имеющие дело с параметризованными типами, называются параметризованными или обобщениями, параметризованными (обобщенными) классами или параметризованными (обобщёнными) методами.

### [[Создание и время жизни объектов]]
**Каждый объект в Java существует (живёт), пока хотя бы одна переменная хранит его адрес (на него есть хотя бы одна ссылка).** Если ссылок больше не остаётся, объект умирает.

Если создать объект в каком-нибудь методе и сохранить ссылку на него в переменную класса, то объект будет существовать всё время, пока существует ссылка на него из другого живого объекта.

Обычно объект уничтожается не сразу. Java-машина время от времени запускает уборку мусора — уничтожение неиспользуемых объектов.
### [[Обработка исключений]]
В мире программирования возникновение ошибок и непредвиденных ситуаций при выполнении программы называют исключением (exception). В программе исключения могут возникать в результате неправильных действий пользователя, отсутствии необходимого ресурса на диске, или потери соединения с сервером по сети.

В языке Java предусмотрены специальные средства для обработки исключений. Одним из таких средств является конструкция try...catch...finally. При возникновении исключения в блоке try управление переходит в блок catch, который может обработать данное исключение. Если такого блока не найдено, то пользователю отображается сообщение о необработанном исключении, а дальнейшее выполнение программы останавливается. И чтобы подобной остановки не произошло, и надо использовать блок try..catch. Например:

|   |   |
|---|---|
|1<br><br>2<br><br>3|`int``[] numbers =` `new` `int``[``3``];`<br><br>`numbers[``4``]=``45``;`<br><br>`System.out.println(numbers[``4``]);`|

Так как у нас массив numbers может содержать только 3 элемента, то при выполнении инструкции `numbers[4]=45` консоль отобразит исключение, и выполнение программы будет завершено. Теперь попробуем обработать это исключение:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10|`try``{`<br><br>    `int``[] numbers =` `new` `int``[``3``];`<br><br>    `numbers[``4``]=``45``;`<br><br>    `System.out.println(numbers[``4``]);`<br><br>`}`<br><br>`catch``(Exception ex){`<br><br>    `ex.printStackTrace();`<br><br>`}`<br><br>`System.out.println(``"Программа завершена"``);`|

При использовании блока try...catch вначале выполняются все инструкции между операторами try и catch. Если в блоке try вдруг возникает исключение, то обычный порядок выполнения останавливается и переходит к инструкции сatch. Поэтому когда выполнение программы дойдет до строки `numbers[4]=45;`, программа остановится и перейдет к блоку `catch`

Выражение catch имеет следующий синтаксис: `catch (тип_исключения имя_переменной)`. В данном случае объявляется переменная `ex`, которая имеет тип `Exception`. Но если возникшее исключение не является исключением типа, указанного в инструкции сatch, то оно не обрабатывается, а программа просто зависает или выбрасывает сообщение об ошибке.

Но так как тип `Exception` является базовым классом для всех исключений, то выражение `catch (Exception ex)` будет обрабатывать практически все исключения. Обработка же исключения в данном случае сводится к выводу на консоль стека трассировки ошибки с помощью метода `printStackTrace()`, определенного в классе Exception.

После завершения выполнения блока catch программа продолжает свою работу, выполняя все остальные инструкции после блока catch.

Конструкция try..catch также может иметь блок `finally`. Однако этот блок необязательный, и его можно при обработке исключений опускать. Блок `finally` выполняется в любом случае, возникло ли исключение в блоке try или нет:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13|`try``{`<br><br>    `int``[] numbers =` `new` `int``[``3``];`<br><br>    `numbers[``4``]=``45``;`<br><br>    `System.out.println(numbers[``4``]);`<br><br>`}`<br><br>`catch``(Exception ex){`<br><br>    `ex.printStackTrace();`<br><br>`}`<br><br>`finally``{`<br><br>    `System.out.println(``"Блок finally"``);`<br><br>`}`<br><br>`System.out.println(``"Программа завершена"``);`|

### Обработка нескольких исключений

В Java имеется множество различных типов исключений, и мы можем разграничить их обработку, включив дополнительные блоки catch:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13|`int``[] numbers =` `new` `int``[``3``];`<br><br>`try``{`<br><br>    `numbers[``6``]=``45``;`<br><br>    `numbers[``6``]=Integer.parseInt(``"gfd"``);`<br><br>`}`<br><br>`catch``(ArrayIndexOutOfBoundsException ex){`<br><br>    `System.out.println(``"Выход за пределы массива"``);`<br><br>`}`<br><br>`catch``(NumberFormatException ex){`<br><br>    `System.out.println(``"Ошибка преобразования из строки в число"``);`<br><br>`}`|

Если у нас возникает исключение определенного типа, то оно переходит к соответствующему блоку catch.

### Оператор throw

Чтобы сообщить о выполнении исключительных ситуаций в программе, можно использовать оператор throw. То есть с помощью этого оператора мы сами можем создать исключение и вызвать его в процессе выполнения. Например, в нашей программе происходит ввод числа, и мы хотим, чтобы, если число больше 30, то возникало исключение:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21|`package` `firstapp;`<br><br>`import` `java.util.Scanner;`<br><br>`public` `class` `FirstApp {`<br><br>    `public` `static` `void` `main(String[] args) {`<br><br>        `try``{`<br><br>            `Scanner in =` `new` `Scanner(System.in);`<br><br>            `int` `x = in.nextInt();`<br><br>            `if``(x>=``30``){`<br><br>               `throw` `new` `Exception(``"Число х должно быть меньше 30"``);`<br><br>           `}`<br><br>        `}`<br><br>        `catch``(Exception ex){`<br><br>            `System.out.println(ex.getMessage());`<br><br>        `}`<br><br>        `System.out.println(``"Программа завершена"``);`<br><br>    `}`  <br><br>`}`|

Здесь для создания объекта исключения используется конструктор класса Exception, в который передается сообщение об исключении. И если число х окажется больше 29, то будет выброшено исключение и управление перейдет к блоку catch.

В блоке catch мы можем получить сообщение об исключении с помощью метода `getMessage()`.
### [[Параллельное выполнение]]
Многопоточность — это важная концепция в программировании, позволяющая выполнять несколько задач одновременно. В Java многопоточность реализуется с помощью класса `Thread` и интерфейса `Runnable`. Многопоточность позволяет улучшить производительность приложений, особенно на многоядерных процессорах, за счет параллельного выполнения задач. Это особенно актуально в современных приложениях, где требуется высокая производительность и отзывчивость.
